package com.reyco.algorithm.hash;

/**
 * 1,32位无符号整数范围是0~42,9496,7295；现在有一个正好包含40亿个无符号整数的文件;
 * 所有在这个范围中必然存在没出现过的数。最少使用1GB的内存，怎么找到所有未出现过的数
 * 答：使用2^32-1的bit数组,空间500M，每个位置用来表示这个数出现过还是未出现过。
 * 
 * 2,32位无符号整数范围是0~42,9496,7295；现在有一个正好包含40亿个无符号整数，可以使用最多
 * 1GB的内存，找出所有出现了两次的数。
 * 答：方法一：先使用哈希表分流到多个小文件，然后对单个小文件作哈希词频统计。
 *    方法二(位图)：用两位表示一个数出现的次数。(2^32*2)/8 Bit
 * 
 * 3,进阶：使用10MB的内存，找到40亿个数的中位数
 * 答：把所有的数分成2048份，把2048分成两份，哪份超过20亿，中位数就在那一份中，对那一份继续找
 * 
 * 
 * 4,进阶：只能使用10kB空间 ，只需要找到一个未出现过的数即可！
 *    需要申请的int数组大小：10240/4=2560  2560>2^N=2048 int[2048]，把所有的数分成2048份，  每份包含的数范围在：(2^32)/2048=2097152
 *    int[i] = 2097152*i~2097152*(i+1)；在int[i]上作词频统计，哪份(int[i])不够2097152个数，再在int[i]上分成若干份，一直这样下去
 * @author reyco
 *
 */
public class Test2 {
	public static void main(String[] args) {
		//10KB = 1024*10 = 10240
		int num = 10240/4;
		int maxLength = maxLength(num);
		int[] b = new int[maxLength];
		
		System.out.println(maxLength);
	}
	public static int maxLength(int num) {
		int curr = 2;
		while((curr<<1)<num) {
			curr = curr<<1;
		}
		return curr;
	}
}
